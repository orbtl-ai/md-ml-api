from typing import Tuple
from PIL import Image
from io import BytesIO
import numpy as np
import os

def ingest_image(image_encoded) -> Image.Image:
    '''
    A simple function that opens a ByteEncoded image (received via POST request), opens as a PIL Image.Image, converts
    to a 3-band RGB image if neccecary, and returns 3-band PIL Image.Image.

    -  INPUTS: 
      -  Encoded Image
    
    -  OUTPUTS:
      -  3-band RGB PIL Image.Image object
    '''
    img = Image.open(BytesIO(image_encoded))

    if(img.mode!='RGB'):
        print("Converting to RGB!")
        img = img.convert("RGB")
    
    return img

def calc_gsd(flight_agl_meters, sensor_focal_length_mm, image_height, image_width, sensor_height_cm, sensor_width_cm) -> Tuple:
    '''
    A simple function that esitmates the ground spacing distance (GSD) of non-georeferenced aerial photographs. Both the GSD in the Y and X
    dimensions are returned to the user.

    -  INPUTS:
      -  flight_agl_meters: a float (decimal) or integer value representing the sensor's height above ground level (AGL) at the time of image
           acquisition. Units are required to be meters.
      -  sensor_focal_length_mm: A string, float, or integer value representing the sensor's focal length in millimeters.
      -  image_height, image_width: Integer values representing the height and width of the image in pixels
      -  sensor_height_cm, sensor_width_cm: The height and width of the sensor in centimeters.
    
    - OUTPUTS:
      -  Tuple containing the input image's ground spacing distance (GSD) in both the height and width dimensions.
    '''
    flight_agl_cm = flight_agl_meters * 1000
    sensor_focal_length_mm = float(sensor_focal_length_mm)
    
    gsd_h = (flight_agl_cm * sensor_height_cm) / (sensor_focal_length_mm * image_height)
    gsd_w = (flight_agl_cm * sensor_width_cm) / (sensor_focal_length_mm * image_width)
    
    return (gsd_h, gsd_w)

def resize_to_gsd(input_image, estimated_gsd_cm, temp_output_path, target_gsd_cm=2.0) -> Image.Image:
    '''
    A simple function that computes a scaling factor between the non-georeferenced input image's estimated GSD and the project's target GSD and
    applies the computed scaling factor to the original image. The result is a resampled image with GSD matching this project's target of 2.0cm.

    -  INPUTS:
      -  input_image: A 3-band PIL Image.Image. This is generally expected to have been generated by the ingest_image() function.
      -  estimated_gsd_cm: The input_image's estimated ground spacing distance (GSD) in centimeters. This value is generally expected to have been
           computed by the calc_gsd() function.
      -  target_gsd_cm: The project's target ground spacing distance (GSD). The output image will be reampled to this GSD. This value defaults to
           the project's target GSD of 2.0 cm. 
    
    - OUTPUTS:
      -  A PIL Image.Image object resampled to the target GSD.
    '''
    upscale_factor = (estimated_gsd_cm - target_gsd_cm) / target_gsd_cm

    output_width = int(input_image.width + (input_image.width * upscale_factor))
    output_height = int(input_image.height + (input_image.height * upscale_factor))
    new_size = (output_width, output_height)
    
    new_im = input_image.resize(new_size)
    
    new_im.save(temp_output_path)
    return new_im

def chip(im, base_img_name, base_img_ext, chip_dir, desired_height=512, desired_width=512) -> dict:
    '''
    This function chips the pre-processed input imagery into "image chips" of desired height/width. The "image_chip" format is suitable for performing
    model inference upon. Currently this routine simply chips the input image using no overlap. Also, image chips smaller than 512x512 are padded with 
    black borders. The output is a dictionary where the key values are each image chips's unique name and the values are 3-D numpy arrays which represent
    the image chip's raw pixel values. Each image chip's unique name is of the format "imageBasename_topLeftPixelY_topLeftPixelX.jpg"

    -  INPUTS:
      -  im: a pre-processed PIL Image.Image object. This object must be 3 bands (RGB) and is expected to have been resampled to a ground spacing 
           distance of 2.0 cm. 
      -  base_img_name: the filename associated with im. This is used as the basename for each unique chip name.
      -  chip_dir: the temporary directory in which to store image chips
      -  desired_height, desired_width: the image chip dimensions in pixels expected by the inference model. Defaults to project value of 512x512 pixels.
    
    -  OUTPUTS:
      - chip_dict: a Python dictionary that contains each unique chip name as the keys, and the raw chip values stored as 3-D numpy arrays. This output
          is designed to be fed directly into the backend API's batch_inference() function.
    '''
    img_width, img_height = im.size

    chip_dict = {}
    for i in range(0, img_height, desired_height):
        for j in range(0, img_width, desired_width):
            box = (j, i, j + desired_width, i + desired_height)
            a = im.crop(box)

            out_name = f"{base_img_name}_{i}_{j}{base_img_ext}"

            a.save(os.path.join(chip_dir, out_name))
            
            chip_array = np.array(a)
            chip_dict[out_name] = chip_array

    print(f"Num of inference images: {len(chip_dict)}")

    return chip_dict

def reassemble_chips(inference_results_dict) -> dict:
  merged_results_dict = {}
  new_bboxes = []
  new_scores = []
  new_classes = []
  for k, v in inference_results_dict.items():
    chip_name, chip_ext = os.path.splitext(k)
    base_name = '_'.join(chip_name.split('_')[:-2])
    x_offset = int(chip_name.split('_')[-1])
    y_offset = int(chip_name.split('_')[-2])

    for bbox in v['bboxes']:
      new_bbox = (y_offset + bbox[0], x_offset + bbox[1], y_offset + bbox[2], x_offset + bbox[3])
      new_bboxes.append(new_bbox)
    for score in v['scores']:
      new_scores.append(score)
    for classes in v['classes']:
      new_classes.append(classes)
    
  merged_results_dict[base_name+chip_ext] = {'bboxes':new_bboxes, 'scores':new_scores, 'classes':new_classes}
 
  return merged_results_dict


    
